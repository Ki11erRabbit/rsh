// Misc

WHITESPACE = _{ " " | "\t" | "\r" | "\\\n" }

newline = { "\r" | "\r\n" | "\n"} 

COMMENT = _{"#" ~(!("\n") ~ ANY)*}

var_name_char = _{ "_" | ASCII_ALPHANUMERIC }
word_char = _{
    !(
        "|" | "&" | ";" | " " | "\t" | "\r" | "\n" | "`"
        | "{" | "}" | "<" | ">" | "(" | ")" | "$" | "\"" | "'" | "*" | "?"
    )
    ~ ANY
}
/// --prefix=~/usr
//  ^^^^^^^^
assign_like_prefix_chars = _{
    "-" | "_" | ASCII_ALPHANUMERIC
}
assign_like_prefix_var_name = ${ assign_like_prefix_chars+ }

username = ${ (!("/") ~ word_char)+ }
//whitespace newline
wsnl = _{ (WHITESPACE | COMMENT | newline)+}


special_var_name = _{ "?" | "$" | "!" | "-" | "#" | "@" | "*" | ASCII_DIGIT }


var_name = ${ var_name_char+ }

index = { ("[" ~ expression ~ "]")? }

number = ${ ASCII_DIGIT+ }


// Expression

expression = !{ assign ~ (compare_op ~ expression)? }

compare_op = { "==" | "!=" | "<" | ">" | "<=" | ">=" | "-eq" | "-ne" | "-lt" | "-gt" | "-le" | "-ge" }

assign = { (var_name ~ assign_op ~ assign) | arithmetic }
assign_op = { "=" }

arithmetic = { term ~ (arithmetic_op ~ arithmetic)? }
arithmetic_op = { "+" | "-" }
term = { factor ~ (factor_op ~ term)? }
factor_op = { "*" | "/" | "%" }
factor = { sign ~ primary ~ postfix_op }
sign = { ("+" | "-")? }
postfix_op = { ("++" | "--")? }
primary = _{ number | ("$"? ~ var_name) | parameter_expansion_span | ("(" ~ expression ~ ")") }


// Word

word = ${ assign_like_prefix? ~ (tilde_span | span) ~ span* }
assign_like_prefix = { assign_like_prefix_var_name ~ "=" }

span = _{
    double_quoted_span
    | single_quoted_span
    | wildcard_string_span
    | wildcard_char_span
    | expression_span
    | command_span
    | backtick_span
    | parameter_expansion_span
    | parameter_span
    | literal_span
}

escaped_char = { "\\" ~ ANY }
unescaped_char = { word_char }
literal_span = ${ (escaped_char | unescaped_char)+ }
tilde_span = { "~" ~ username? }
wildcard_string_span = { "*" }
wildcard_char_span = { "?" }
command_span = !{ "$(" ~ compound_list ~ ")" }
backtick_span = { "`" ~ compound_list ~ "`" }
expression_span = { "$((" ~ expression ~ "))" }
expandable_var_name = { var_name | special_var_name }

length_op = { "#"? }
parameter_op = { ":=" | ":-" | "-" | "//" | "/" }
parameter_option = { parameter_op ~ word? }
parameter_expansion_span = { "$" ~ "{" ~ length_op ~expandable_var_name ~ index ~ parameter_option? ~ "}" }
parameter_span = { "$" ~ expandable_var_name }

double_quoted_span = { "\"" ~ double_quoted_span_inner* ~ "\"" }
double_quoted_span_inner = _{
    expression_span
    | backtick_span
    | command_span
    | parameter_expansion_span
    | parameter_span
    | literal_in_double_quoted_span
}

single_quoted_span = { "'" ~ single_quoted_span_inner* ~ "'" }
single_quoted_span_inner = _{
    literal_in_single_quoted_span
}

literal_in_double_quoted_span = ${
    (
        !("\"" | "\\" | "`" | "$") ~ ANY
        | "\\" ~ ANY
        | WHITESPACE
    )+
}

literal_in_single_quoted_span = ${ ( "\\'"  | !("\'") ~ ANY | WHITESPACE)+ }


// Assignment

initializer = { array_initializer | string_initializer }
string_initializer = { word }
array_initializer = { ("(" ~ word* ~ ")") }

assignment = { var_name ~ index ~ "=" ~ initializer ~ WHITESPACE? } 
assignment_command = { assignment+}


// Simple Command

file_descriptor = { ASCII_DIGIT* }
redirect_direction = { ("<" | ">" | ">>") }
redirect_to_file_descriptor = ${ "&" ~ file_descriptor }
redirect = { file_descriptor ~ redirect_direction ~ (word | redirect_to_file_descriptor) }
word_or_redirect = _{ redirect | word }

reserved_word = ${
    (
        "break"
        | "case"
        | "continue"
        | "done"
        | "do"
        | "elif"
        | "else"
        | "esac"
        | "fi"
        | "for"
        | "function"
        | "if"
        | "in"
        | "local"
        | "return"
        | "then"
        | "while"
    ) ~ !(word_char)
}

argv0 = { !reserved_word ~ word }
args = { word_or_redirect* }
assignments = { assignment* }
simple_command = { assignments ~ argv0 ~ args }


// If Command


if_command = {
    "if" ~ compound_list ~
    "then" ~ compound_list ~
    elif_part* ~
    else_part? ~
    "fi"
}
elif_part = { "elif" ~ compound_list ~ "then" ~ compound_list }
else_part = { "else" ~ compound_list }


// While Command

while_command = { "while" ~ compound_list ~ "do" ~ compound_list ~ "done" }


// For Command

word_list = { (!reserved_word ~ word)* }

for_command = {
    "for" ~ var_name ~ "in" ~ word_list ~ (";" | wsnl)+ ~ "do" ~ compound_list ~ "done"
}


arithmetic_for_expression = { "((" ~ expression ~ ";" ~ expression ~ ";" ~ expression ~ "))" }
arithmetic_for_command = {
    "for" ~ arithmetic_for_expression ~ (";" | wsnl)+ ~ "do" ~ compound_list ~ "done"
}


// Case Command

patterns = { word ~ ("|" ~ word)* }
case_item = {
    !("esac") ~ patterns ~ ")" ~ compound_list ~ ";;"
}

case_command = {
    "case" ~ word ~ "in" ~ (wsnl | case_item)* ~ "esac"
}


// Function Definition

function_definition = {
    ("function")? ~ var_name ~ "()" ~ wsnl? ~ command
}


// Local Variable Definition

local_definition = { "local" ~ (assignment | var_name)+ }


// Return/Break/Continue Command


return_command = { "return" ~ number? }
break_command = { "break" }
continue_command = { "continue" }


// Group ( '{...}' )

group = { "{" ~ compound_list ~ "}" }


// Subshell Group ( '(...)' )

subshell_group = { "(" ~ compound_list ~ ")" }




// Command

command = {
    if_command
    | while_command
    | for_command
    | arithmetic_for_command
    | break_command
    | continue_command
    | case_command
    | function_definition
    | local_definition
    | return_command
    | group
    | subshell_group
    | simple_command
    | assignment_command
}

// Pipeline '|'

pipeline = { command ~ ((!("||") ~ "|") ~ wsnl? ~ command)* }


// And/Or List ('&&' or '||')

and_or_list = { pipeline ~ (and_or_list_separator ~ wsnl? ~ and_or_list)* }
and_or_list_separator = { "&&" | "||" }


// Compound List (";" or "&")

compound_list = { compound_list_inner ~ (compound_list_separator ~ wsnl? ~ compound_list)*}
compound_list_separator = { (!(";;") ~ sequence_separator) | !("&&") ~ background | newline }
sequence_separator = { ";" }
background = { "&" }
empty_line = {""}
compound_list_inner = _{ and_or_list | empty_line }


// Script

script = _{SOI ~ compound_list ~ EOI}
